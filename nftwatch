#!/usr/bin/python3
# vim:set shiftwidth=4 expandtab:


'''
nftwatch
========

![](nftwatch.png)

Copyright (C) 2021-2022 Kenneth Aaron.

flyingrhino AT orcon DOT net DOT nz

Freedom makes a better world: released under GNU GPLv3.

https://www.gnu.org/licenses/gpl-3.0.en.html

This software can be used by anyone at no cost, however,
if you like using my software and can support - please
donate money to a children's hospital of your choice.

This program is free software: you can redistribute it
and/or modify it under the terms of the GNU General Public
License as published by the Free Software Foundation:
GNU GPLv3. You must include this entire text with your
distribution.

This program is distributed in the hope that it will be
useful, but WITHOUT ANY WARRANTY; without even the implied
warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
PURPOSE.
See the GNU General Public License for more details.


About nftwatch
--------------

* Shows nftables policy in a more readable format.
* Live counters table.
* User-configurable refresh speed.
* Pause display refresh.


Manual install instructions
---------------------------

* Clone/download the project from the git repository.
* Copy:  `/etc/nftwatch.yml`    .
* Copy:  `/usr/local/bin/nftwatch`  and:  +x  it.
* `nftwatch`  with no args to run it.
* `nftwatch -m`  for this man page.


Configuring nftwatch
--------------------

Some configs are in:  `nftwatch.yml`    .
Others are hardcoded into the code - subject to improvement.
Config file will be loaded from these paths - whichever
is found first. If no config file is found - builtin
defaults will be used.
It's safe to run nftwatch without a config file.

* ~/.config/nftwatch/nftwatch.yml
* ~/.nftwatch.yml
* ~/nftwatch.yml
* /etc/nftwatch.yml


Controls
--------

nftwatch is designed for interactive use. Simply run it
and it will start displaying your nftables stats.

The following keyboard controls are available:

- f:                Speed up the display refresh
- s:                Slow down the display refresh
- p:                Pause the display refresh
- .:                Toggles comment dot padding
- ,:                Toggles even more dot padding
- Up arrow or N:    Scroll the table up
- Down arrow or n:  Scroll the table down
- Home or g:        Jump to table top
- End or G:         Jump to table bottom
- PgUp or b:        Page up in the table
- PgDn or space:    Page down in the table
- Ctrl-q or q:      Quit


Man page
--------

* `nftwatch -m`  for this man page.


Usage tips
----------

* If you see something interesting - pause the display
and scroll the table if needed.
* Add counters to your nftables rules if you want to see
these values in nftwatch (by default rules don't have
counters).
* Slow down your display refresh rate to get more accurate
results, as well as pickup rules that are rarely hit.
At faster refresh rates your BPS/PPS rates will be
higher than reality because the time it takes to read and
calculate values is not accounted for (nftwatch uses
simple division by refresh time per cycle).
* If short comments make it difficult to follow the line -
toggle dot padding with:  `.`  to improve readability.
Change will apply at next table redraw.
And if this isn't enough:  `,`  will give you even more
padding.


Troubleshooting
---------------

Increase the logging verbosity with:  `nftwatch -d`
or permanently increase it in the code by changing this
line:  `LogLevel = logging.DEBUG`    .
Check  `journalctl -f`  for nftwatch logs.

On rare occasions nftwatch exits and leaves the terminal
messed up. Fix this by typing:  `reset`  in the terminal.
I tried to fix this at the end of function:  main
but I still see it happen 5% of the time when running fast
refresh rates.
If anyone knows a solution please tell me.


Limitations
-----------

- This is the first release of nftwatch.
- There could be bugs.
- It can be improved.
- Features can be added.
- nftwatch is tied to the nft output. Any changes in nft
output will break nftwatch.
- Supports up to 9999 lines/nft-handles before display may
get messed up. Should be enough for most use cases though.
- The first cycle after changing refresh speed will be
incorrect; the second cycle onwards will be fine until
you change refresh speed again.
- nftwatch is not a performance measurement tool - there
are a few factors that prevent the BPS and PPS rates from
being accurate, but as a rules troubleshooting assistant -
it is close enough to be useful.

I initially wrote nftwatch because I wanted a realtime
running output from nftables that was better than simply
looping it through:  `watch`. As of now - nftwatch serves
its purpose. Let's see what feature requests I receive and
if nftwatch can be improved for more use cases.


'''

# Standard library imports:
import argparse
import collections
import curses
import datetime
import getpass
import itertools
import logging
import logging.handlers
import operator
import os
import pathlib
import pydoc
import re
import shlex
import string
import subprocess
import sys
import textwrap
import threading
import time
import typing

# Pay attention to these imports:
import yaml         # Requires: 'pip3 install --user PyYAML'
                    #   On a Debian based system you can also do:
                    #       sudo apt-get install python3-yaml
                    #   On Fedora you can do:
                    #       dnf install python3-pyyaml


# Beginning of logging setup section:

# Variables that control logging:
LogLevel = logging.INFO
    # ^ Initial log level of this program.
    #       Edit this if you want to change the initial log level.
    #       Supported levels: DEBUG, INFO, WARNING, ERROR, CRITICAL .
MaxLogLineLength = 700
    # ^ Wrap log lines longer than this many chars.
    #   Keep a sensible and usable limit.
SysLogProgName = 'nftwatch'
    # ^ This is how our program is identified in syslog.
    #       Use:  journalctl -f -t 'nftwatch'  to watch its logs.
Indent = 8
    # ^ Wrapped lines are indented by n spaces to make
    #       logging easier to read.
    #   This field is optional.
IndentChar = '.'
    # ^ What sub character to use for indenting.
    #   This field is optional.
EnhancedLogging = True
    # ^ Use the fancy log line splitting (set to True).
    #   This includes forced splitting the supplied text at
    #       any \n newline marks.
    #   Send log line as-is to syslog (set to False) -
    #       you are responsible for line length constraints.
SecureLogging = False
    # ^ LogWrite supports safe logging if called in a particular way.
    #       This allows you to code two versions of your log line and
    #       depending upon this variable - one of the two will be logged.
    #       For example - the 'unsafe' version is used during debugging and
    #       the 'safe' version is used during production.
    #   To use this feature - call LogWrite with a dict:
    #       LogWrite.info( { 'safe': 'This message is CENSORED',
    #           'unsafe': 'Sensitive information here' } )
    #   If SecureLogging == True - the 'safe' value is logged.
    #   If SecureLogging == False - the 'unsafe' value is logged.
    #
    #   If you want simple logging - call LogWrite with a string:
    #       LogWrite.info('This will be logged as is')
    #
    #   You can also supply the dict:  'tee': "text to print"
    #       which saves you writing two lines (one for print and one for logging)
    #       per how you supply the dict (see the examples in the code later on):
    #   LogWrite.info( { 'tee': 'The same line gets printed to display and logged.'} )
    #   LogWrite.info( { 'tee': 'User line to display', 'safe': 'CENSORED line gets logged' } )


# Program identification strings:
__version__     = '1.0.12'
VersionDate     = '2022-05-07'
ProgramName     = 'nftables counters watcher'
AuthorName      = 'Kenneth Aaron'
AuthorEmail     = 'flyingrhino AT orcon DOT net DOT nz'
License         = 'GPLv3'


# This block handles logging to syslog:
class CustomHandler(logging.handlers.SysLogHandler):
    ''' Subclass for our custom log handler '''

    def __init__(self):
        super(CustomHandler, self).__init__(address = '/dev/log')
            # ^ Very important to send the address bit to SysLogHandler
            #   else you won't get logging in syslog!


    def emit(self, record):
        ''' Method for returning log lines to SysLogHandler.
            Here is where we split long lines into smaller slices and
            each slice gets logged with the appropriate syslog formatting,
            as well as the identifiers we add that clearly state where
            wrapping occurred.
        '''

        # This block deals with safe/unsafe/ignore LogWrite calls:
        if isinstance(record.msg, str):
            # ^ LogWrite was called with a basic string - ignore the SecureLogging setting
            #       and log the line as is.
            pass

        elif isinstance(record.msg, dict):
            # ^ LogWrite was called with a dict - log either safe/unsafe
            #       per SecureLogging setting.

            if 'tee' in record.msg:
                # ^ Dict key == tee means print the message to screen, and later choose
                #       which version gets logged.
                print(record.msg['tee'])

            if SecureLogging:
                # ^ In:  SecureLogging == True  mode - try to log the:  safe  value if found,
                #       else log the:  tee  value:
                if 'safe' in record.msg:
                    record.msg = record.msg['safe']
                else:
                    record.msg = record.msg['tee']
                    #record.msg = "No safe message was supplied."
                        # ^ At the moment we are logging the:  tee  value if no:  safe  value is supplied,
                        #       but a safer option could be to force log a notification string as in the
                        #       commented out line - you choose which better suits you.

            else:
                # ^ In:  SecureLogging == False  mode - try to log the:  unsafe  value if found,
                #       else log the:  tee  value:
                if 'unsafe' in record.msg:
                    record.msg = record.msg['unsafe']
                else:
                    record.msg = record.msg['tee']

        if EnhancedLogging:
            # ^ We will split the supplied log line (record.msg) into multiple lines.
            #   First - split the message at whatver \n newline chars were supplied
            #   by the caller (even before our own fancy splitting is done):

            RecordMsgSplitNL = record.msg.splitlines()
                # ^ If the log message supplied contains new lines we will split
                #   it at the newline mark - each split logged as a separate line.
                #   The splitlines() method creates RecordMsgSplitNL as a list,
                #   even if there was only one line in the original log message.
                #   Note - lines split because of \n will not get the !!LINEWRAPPED!!
                #   text prepended/appended at the split points.

            SplitLinesMessage = []
                # ^ Final version of line splitting

            for LineLooper in RecordMsgSplitNL:
                if len(LineLooper) < MaxLogLineLength:
                    # ^ Normal line length detected
                    SplitLinesMessage.append(LineLooper)

                else:
                    # ^ Long line detected, need to split
                    TempTextWrapLines = (textwrap.wrap(
                        LineLooper,
                        width=(MaxLogLineLength - 15),
                        subsequent_indent='!!LINEWRAPPED!!',
                        drop_whitespace=False))
                        # ^ If line to log is longer than MaxLogLineLength -
                        #   split it into multiple lines and prepend !!LINEWRAPPED!!
                        #   to the subsequent lines created by the split.

                        # ^ Note - We subtract 15 because we're adding !!LINEWRAPPED!!
                        #   at the end of lines, and we don't want the total length
                        #   of the log line to exceed MaxLogLineLength .

                        # ^ Note - textwrap.wrap doesn't know how to append text
                        #   to wrapped lines, so we must do it manually later.

                        # ^ Note - textwrap.wrap returns a list.

                    #   If we needed to wrap long lines let's append the !!LINEWRAPPED!!
                    #   text to the end of all lines except the last one:
                    if len(TempTextWrapLines) > 1:
                        for Looper in range(len(TempTextWrapLines)-1):
                            TempTextWrapLines[Looper] = ( TempTextWrapLines[Looper] +
                                '!!LINEWRAPPED!!' )

                    SplitLinesMessage.extend(TempTextWrapLines)

            # Finally, return the lines to the class,
            # adding the indent to lines #2 and above if required:
            for Counter, Looper in enumerate(SplitLinesMessage):
                if Counter > 0:
                    Looper = ( ((Indent - 4) * ' ') +
                        (IndentChar * 4) +
                        Looper )
                        # ^ This adds the indent and .... to all subsequent lines
                        #   after the first line - and applies to ALL LINES from
                        #   the second onwards, both for lines split on newline
                        #   and lines split on length!
                        #   Don't be confused if some lines don't have the
                        #   !!LINEWRAPPED!! text in them - there could be \n in
                        #   the string passed, and we made new lines from that.
                record.msg = Looper
                super(CustomHandler, self).emit(record)

        else:
            super(CustomHandler, self).emit(record)
                # ^ Pass it through as-is


#logging.disable(level=logging.CRITICAL)
    # ^ Uncomment this if you want to completely disable logging regardless of any
    #   logging settings made anywhere else.

LogWrite = logging.getLogger(SysLogProgName)
LogWrite.setLevel(LogLevel)
    # ^ Set this to logging.DEBUG or logging.WARNING for your INITIAL desired log level.
    #   Config file (nftwatch.yml) log level takes over from when it is loaded,
    #   This value controls logging verbosity until then so if you really want
    #       debug level logging throughout your session, use 'nftwatch -d' .
    #   If you need to see verbose logging BEFORE the nftwatch.yml is loaded (which
    #       overrides this setting), make it DEBUG here. Well - don't actually edit it
    #       here, but edit it in the earlier section 'Variables that control logging'
    #       where the variable 'LogLevel' is configured.
    #   This will also let you troubleshoot problems that occur in the initial stages
    #       of nftwatch run - before the nftwatch.yml file is loaded.

LogWrite.propagate = False
    # ^ Prevents duplicate logging by ancestor loggers (if any)

LogHandler = CustomHandler()
LogWrite.addHandler(LogHandler)

LogWriteFormatter = logging.Formatter(
    fmt = '{}[%(process)d]: <%(levelname)s> '
        '(%(asctime)s.%(msecs)03d , PN: %(processName)s , MN: %(module)s , '
        'FN: %(funcName)s , '
        'LI: %(lineno)d , TN: %(threadName)s):    '
        '%(message)s'.format(SysLogProgName),
    datefmt = '%Y-%m-%d %H:%M:%S' )
    # ^ Select the attributes to include in the log lines
    #   Documented here: https://docs.python.org/3/library/logging.html
    #     (LogRecord attributes)
    #
    #   Note: On Python 3.6+ we can get millisecond date using:
    #       datetime.datetime.now().isoformat(sep=' ', timespec='milliseconds')
    #
    #   Note: Any variables passed in the:  format(...)  section are fixed for the
    #       duration of the run - don't use it to pass in a timestamp because it will
    #       not change - ever.
    #   This version gives dot milliseconds rather than the default comma as in
    #       the builtin python function.
    #       See here: https://stackoverflow.com/questions/6290739/python-logging-use-milliseconds-in-time-format

    # Fields explained:
    #   PN: Process Name
    #   MN: Module Name (Also the file name of the first py file that is run
    #       or the name of the symlink that ran it)
    #   FN: Function Name
    #   LI: LIne number
    #   TN: Thread Name
    #
    #       LN: Logger Name (This is the contents of variable: SysLogProgName)
    #           I'm not using it because it's already used in the first {} of:
    #               {}[%(process)d]:

    # Example:
    #   Dec 29 14:35:29 asus303 nftwatch[31470]: <DEBUG> (2020-12-29 14:35:29.048 ,
    #   PN: MainProcess , MN: cm , FN: SetupWindows , LI: 1268 , TN: MainThread):
    #   ConnectionsList window built

LogHandler.setFormatter(LogWriteFormatter)
LogWrite.debug('nftwatch started with log level == {} as set by '
    'LogWrite.setLevel (hardcoded in the script)'
        .format(LogWrite.getEffectiveLevel()))
    # ^ Note - this only gets logged if debug level is set in the script
    #   using the LogLevel variable.

# ^ End of logging setup section


# Beginning of global variables section:

class GlobalConfig:
    ''' This is used as a simple global variable storage because GlobalConfig only
        exists in the global scope, all references to it will escalate here. '''

    # ncurses vars:
    # =============

    ScreenHeight = ScreenWidth = 0
        # ^ The terminal window dimensions

    MaxScreenLines = 0
        # ^ Max number of nft rules to display

    CountersWidth = 42
        # ^ Width of the counters output

    DetailsWidth = 0
        # ^ Width of the details output

    MiniSleep = 0.02
        # ^ Allows breakout of loops which have bigger sleep times

    HelpMenuItems = collections.OrderedDict((
        #( 'ctrl-h',     'Help' ),
        ( 'q',     'Quit' ),
    ))

    VerticalOffset = 0
        # ^ Vertical offset into the nftables list
        #       (up/down arrow scrolling in the list)
        #   This will be controlled in function:  MainCursesFunction  to ensure that
        #       scrolled-down displays still fit in the window fully and dont overrun
        #       the length of the list.

    DetailsOffset = 0
        # ^ Horizontal offset into the details window oupput
        #       (left/right arrow scrolling for handling long lines in the details window)

    RefreshScreen = True
        # ^ Set to False if you want to pause output

    SkipSleep = False
        # ^ Skip the sleep set by:  RefreshPeriod  mostly for user interactive actions
        #       such as keypress.

    ForceScreenRedraw = False
        # ^ Force redraw the screen - useful when scrolling the display.



    # Config file vars:
    # =================

    # Setup the supported directories/pathnames for the connections file.
    # If you want to store nftwatch.yml in a directory that's not already supported
    # or change the filename, do it here:
    ConfigFile = 'nftwatch.yml'
    ConfigFilePath = []
        # ^ Try to load nftwatch.yml from these paths whichever is found first
    ConfigFilePath.append(str(pathlib.Path.home()) + '/.config/nftwatch/' + ConfigFile)
        # ^ ~/.config/nftwatch/nftwatch.yml
    ConfigFilePath.append(str(pathlib.Path.home()) + '/.' + ConfigFile)
        # ^ ~/.nftwatch.yml
    ConfigFilePath.append(str(pathlib.Path.home()) + '/' + ConfigFile)
        # ^ ~/nftwatch.yml
    ConfigFilePath.append('/etc/' + ConfigFile)
        # ^ /etc/nftwatch.yml

    NftCommandLine = '/usr/sbin/nft -nn --handle list ruleset'
        # ^ The command line used to read the nftables output.

    RefreshPeriod = 2
        # ^ Refresh the display every n seconds.

    DisplayHandle = True
        # ^ Display the nftables rule handle.

    TruncateComment = 40
        # ^ Truncate the comment text to this length, or 0 to disable truncation.

    TruncateDetails = 0
        # ^ Truncate the details text to this length, or 0 to disable truncation.

    DisplayMode = 'human'
        # ^ Display counters in human or full format

    # rulebase vars:
    # ==============

    Timeout = 2
        # ^ Wait n seconds for command output

    ReLeadingWhitespace = re.compile('^\s+')
        # ^ Look for leading whitespace

    ReCounter = re.compile('counter packets \d+ bytes \d+')
        # ^ Matches:  "counter packets x bytes y"  text

    ReComment = re.compile('comment "(.*?)"')
        # ^ Matches:  'comment "..."'  text

    ReHandle = re.compile(' # handle.*')
        # ^ Matches:  " handle x"  text

    ReMultipleSpaces = re.compile('\s+')
        # ^ Used to replace multiple whitespace with a single space

    ExitProgram = False
        # Tells all threads to quit allowing program exit

    DotPadding = False
        # ^ Pad the comments line with dots - may help readability

    MoreDotPadding = False
        # ^ Pad the comments line with even more dots - may help readability


class NftStats:
    ''' Keep the raw and processed nft stats here.
        Yet another global vars storage item. '''

    LastFullNftOutput = ''
        # ^ Raw output from reading nft rulebase

    LastSplitNftOutput = []
        # ^ Same data as:  LastFullNftOutput  but split into list of lines where each line
        #       is a dict of values.

    LastMaxLengths = {}
        # ^ The maximum field lengths of items from:  LastSplitNftOutput

    PreviousSplitNftOutput = []
        # ^ Sesond last results. Used for rates calculations.

    PreviousMaxLengths = []
        # ^ The maximum field lengths of items from:  PreviousSplitNftOutput

    FreezeSplitNftOutput = []
        # ^ This is used for generating window output and allowing scrolling in pause mode.

    FreezeMaxLengths = []
        # ^ The maximum field lengths of items from:  FreezeSplitNftOutput

    NftReadCycle = 0
        # ^ Incremented by 1 each time we read stats from nft

    LenLastRead = 0
        # ^ Length of the:  LastSplitNftOutput  list

    LenPrevRead = 0
        # ^ Length of the:  PreviousSplitNftOutput  list

    LenFreezeRead = 0
        # ^ Length of the:  FreezeSplitNftOutput  list


class Windows:
    ''' This is a placeholder for the various curses windows we will create
        in the:  SetupWindows  function. '''
    pass


# Program begins below:

class HumanVals:
    '''
        Comes from:  https://stackoverflow.com/questions/12523586/python-format-size-application-converting-b-to-kb-mb-gb-tb
        Credit to:  Mitch McMabers  for the original version of this code.

        Examples:
            print(HumanVals.format(2251799813685247)) # 2 pebibytes
            print(HumanVals.format(2000000000000000, True)) # 2 petabytes
            print(HumanVals.format(1099511627776)) # 1 tebibyte
            print(HumanVals.format(1000000000000, True)) # 1 terabyte
            print(HumanVals.format(1000000000, True)) # 1 gigabyte
            print(HumanVals.format(4318498233, precision=3)) # 4.022 gibibytes
            print(HumanVals.format(4318498233, True, 3)) # 4.318 gigabytes
            print(HumanVals.format(-4318498233, precision=2)) # -4.02 gibibytes
    '''

    METRIC_LABELS: typing.List[str] = [" ", "K", "M", "G", "T", "P", "E", "Z", "Y"]
    #BINARY_LABELS: typing.List[str] = [" ", "Ki", "Mi", "Gi", "Ti", "Pi", "Ei", "Zi", "Yi"]
    # ^ Technically this is correct, but I'm saving one char in my output.
    BINARY_LABELS: typing.List[str] = [" ", "K", "M", "G", "T", "P", "E", "Z", "Y"]
    PRECISION_OFFSETS: typing.List[float] = [0.5, 0.05, 0.005, 0.0005] # PREDEFINED FOR SPEED.
    PRECISION_FORMATS: typing.List[str] = ["{}{:.0f} {}", "{}{:.1f} {}", "{}{:.2f} {}", "{}{:.3f} {}"] # PREDEFINED FOR SPEED.

    @staticmethod
    def format(num: typing.Union[int, float], metric: bool=False, precision: int=1) -> str:
        """
        Human-readable formatting of bytes, using binary (powers of 1024)
        or metric (powers of 1000) representation.
        """

        assert isinstance(num, (int, float)), "num must be an int or float"
        assert isinstance(metric, bool), "metric must be a bool"
        assert isinstance(precision, int) and precision >= 0 and precision <= 3, "precision must be an int (range 0-3)"

        unit_labels = HumanVals.METRIC_LABELS if metric else HumanVals.BINARY_LABELS
        last_label = unit_labels[-1]
        unit_step = 1000 if metric else 1024
        unit_step_thresh = unit_step - HumanVals.PRECISION_OFFSETS[precision]

        is_negative = num < 0
        if is_negative: # Faster than ternary assignment or always running abs().
            num = abs(num)

        for unit in unit_labels:

            if num < unit_step_thresh:
                # VERY IMPORTANT:
                # Only accepts the CURRENT unit if we're BELOW the threshold where
                # float rounding behavior would place us into the NEXT unit: F.ex.
                # when rounding a float to 1 decimal, any number ">= 1023.95" will
                # be rounded to "1024.0". Obviously we don't want ugly output such
                # as "1024.0 KiB", since the proper term for that is "1.0 MiB".
                break

            if unit != last_label:
                # We only shrink the number if we HAVEN'T reached the last unit.
                # Note: These looped divisions accumulate floating point rounding
                # errors, but each new division pushes the rounding errors further
                # and further down in the decimals, so it doesn't matter at all.
                num /= unit_step

        return HumanVals.PRECISION_FORMATS[precision].format("-" if is_negative else "", num, unit)


def ReadNftOutput():
    ''' Reads the output from nft rulebase '''

    while True:
        #LogWrite.debug('NftStats.NftReadCycle == {}'.format(NftStats.NftReadCycle))
            # ^ Too much logging

        # Setup vars:
        # ===========

        # Read the nft rules outoput (along with counters and other fields) :
        if ( ( ( sys.version_info[0] == 3 ) and ( sys.version_info[1] >= 7 ) )
            or ( sys.version_info[0] > 3 ) ):
            NftOutput = subprocess.run(GlobalConfig.NftCommandLine,
                capture_output=True, timeout=GlobalConfig.Timeout, check=True, text=True, shell=True)
        else:
            NftOutput = subprocess.run(GlobalConfig.NftCommandLine,
                stdout=subprocess.PIPE, timeout=GlobalConfig.Timeout, check=True,
                shell=True, encoding='utf-8')

        NftStats.LastFullNftOutput = NftOutput.stdout
        #LogWrite.debug('NftStats.LastFullNftOutput ==\n{}'.format(NftStats.LastFullNftOutput))
            # ^ Too much logging
        NftStats.LastSplitNftOutput = []
        NftStats.LastMaxLengths = {}
        HandleList = []
            # ^ Used to detect if any duplicate handle numbers exist in the ruleset.

        MaxHandleTextLength = MaxPacketsTextLength = MaxBytesTextLength = 0
        MaxPPSTextLength = MaxBPSTextLength = 0
        MaxCommentTextLength = MaxDetailsTextLength = 0
            # ^ Used to determine the text field lengths for column display

        MaxHumanPacketsTextLength = MaxHumanPPSTextLength = 5
        MaxHumanBytesTextLength = MaxHumanBPSTextLength = 5
            # Same for the human readable values, but since the function does rounding - the max text
            #   length will always be 5 so let's not calculate it because this will result in a window
            #   size that changes too often.


        # Process ruleset line by line:
        # =============================

        for Looper in NftStats.LastFullNftOutput.splitlines():
            # ^ Looping over the recently read stats, line by line
            #LogWrite.info('Cycle number: {} , Processing:  Looper == {}'.format(NftStats.NftReadCycle, Looper))
                # ^ Too much logging


            # Process the leading whitespace value:
            # -------------------------------------

            Result = GlobalConfig.ReLeadingWhitespace.search(Looper)
            if Result:
                LeadingWhitespaceResult = Result.group()
                LeadingWhitespaceResult = LeadingWhitespaceResult.replace('\t', '    ')
                # ^ nftables supplies config blocks indented with tab (8 spaces) which is too much.
                #   Let's reduce it to 4 spaces.

            else:
                LeadingWhitespaceResult = ''

            #LogWrite.info('LeadingWhitespaceResult == "{}"'.format(LeadingWhitespaceResult))
                # ^ Too much logging


            # Process the counters value:
            # ---------------------------

            Result = GlobalConfig.ReCounter.search(Looper)
            if Result:
                CounterResult = Result.group()

                PacketsResult = int(CounterResult.split()[2])
                PacketsTextResult = str(PacketsResult)
                if len(PacketsTextResult) > MaxPacketsTextLength:
                    MaxPacketsTextLength = len(PacketsTextResult)

                BytesResult = int(CounterResult.split()[4])
                BytesTextResult = str(BytesResult)
                if len(BytesTextResult) > MaxBytesTextLength:
                    MaxBytesTextLength = len(BytesTextResult)

            else:
                CounterResult = False
                PacketsResult = BytesResult = -1
                    # ^ There are no counters present but I can't use:  False  on the counters
                    #       because values of:  0  and:  False  are evaluated the same way.
                PacketsTextResult = BytesTextResult = ''

            #LogWrite.info('CounterResult == {} , PacketsResult == {} , BytesResult == {}'.format(CounterResult, PacketsResult, BytesResult))
                # ^ Too much logging


            # Process the comment value:
            # --------------------------

            Result = GlobalConfig.ReComment.search(Looper)
            if Result:
                CommentResult = Result.group()
                CommentResult = CommentResult.strip()
                CommentResult = CommentResult.replace('comment "', '')
                CommentResult = CommentResult[:-1]
                if len(CommentResult) > MaxCommentTextLength:
                    MaxCommentTextLength = len(CommentResult)

            else:
                CommentResult = ''

            #LogWrite.info('CommentResult == {}'.format(CommentResult))
                # ^ Too much logging


            # Process the handle value:
            # -------------------------

            Result = GlobalConfig.ReHandle.search(Looper)
            if Result:
                HandleResult = int(Result.group().split()[2])
                HandleTextResult = str(HandleResult)
                if len(HandleTextResult) > MaxHandleTextLength:
                        MaxHandleTextLength = len(HandleTextResult)

                if HandleResult in HandleList:
                    # ^ Duplicate handle detector
                    #LogWrite.warning('HandleResult == {}  already found in:  HandleList == {} , line Looper == {}'.format(HandleResult, HandleList, Looper))
                        # ^ Too much logging
                    pass

                HandleList.append(HandleResult)

            else:
                HandleResult = False
                HandleTextResult = ''

            #LogWrite.info('HandleResult == {}'.format(HandleResult))
                # ^ Too much logging


            # Process the details value:
            # --------------------------

            # Prepare a value of other text not collected explicitly above.
            #   This will mostly be the rule content:
            DetailsResult = GlobalConfig.ReLeadingWhitespace.sub('', Looper)
            DetailsResult = GlobalConfig.ReCounter.sub('', DetailsResult)
            DetailsResult = GlobalConfig.ReComment.sub('', DetailsResult)
            DetailsResult = GlobalConfig.ReHandle.sub('', DetailsResult)
            DetailsResult = GlobalConfig.ReMultipleSpaces.sub(' ', DetailsResult)
            DetailsResult = DetailsResult.strip()
            if len(DetailsResult) > MaxDetailsTextLength:
                MaxDetailsTextLength = len(DetailsResult)

            #LogWrite.info('DetailsResult == {}'.format(DetailsResult))
                # ^ Too much logging


            # Calculate BPS & PPS values:
            # ---------------------------

            # Prepare the PPS and BPS values (based upon difference with previous reading):
            #LogWrite.debug('Calculating rates for handle: {} ...'.format(HandleResult))
                # ^ Too much logging
            if CounterResult and NftStats.NftReadCycle >= 1:
                # ^ Remember - in the first cycle we have no history therefore we cannot calculate rates.

                for PrevLooper in NftStats.PreviousSplitNftOutput:
                    # ^ Loop over the previous reading and search for a matching handle number

                    if PrevLooper['Handle'] == HandleResult:
                        if ( PrevLooper['DetailsText'] == DetailsResult ) and ( PrevLooper['CommentText'] == CommentResult ):
                            if PacketsResult >=0:
                                PPS = round((PacketsResult - PrevLooper['Packets']) / GlobalConfig.RefreshPeriod)
                                PPSText = str(PPS)
                                if len(PPSText) > MaxPPSTextLength:
                                    MaxPPSTextLength = len(PPSText)
                                HumanPacketsText = str(HumanVals.format(PacketsResult, precision=0))
                                HumanPPSText = str(HumanVals.format(PPS, precision=0))
                            else:
                                PPS = 0
                                PPSText = ''
                                HumanPacketsText = ''
                                HumanPPSText = ''

                            if BytesResult >=0:
                                BPS = round((BytesResult - PrevLooper['Bytes']) / GlobalConfig.RefreshPeriod)
                                BPSText = str(BPS)
                                if len(BPSText) > MaxBPSTextLength:
                                    MaxBPSTextLength = len(BPSText)
                                HumanBytesText = str(HumanVals.format(BytesResult, precision=0))
                                HumanBPSText = str(HumanVals.format(BPS, precision=0))
                            else:
                                BPS = 0
                                BPSText = ''
                                HumanBytesText = ''
                                HumanBPSText = ''

                        else:
                            # Looks like a bug in nft - two identical handles on different rules?
                            #LogWrite.warning('Possible two different rules with the same handle: '
                            #    'HandleResult == {} , PrevLooper[Handle] == {} , DetailsResult = {} , '
                            #    'PrevLooper[DetailsText] == {} , CommentResult == {} , PrevLooper[CommentText] == {}'
                            #        .format(HandleResult, PrevLooper['Handle'], DetailsResult,
                            #            PrevLooper['DetailsText'], CommentResult, PrevLooper['CommentText']))
                                # ^ Too much logging
                            pass

            elif CounterResult and NftStats.NftReadCycle < 1:
                PPS = BPS = 0
                PPSText = BPSText = HumanPacketsText = HumanBytesText = HumanPPSText = HumanBPSText  = ''

            elif not CounterResult:
                # ^ Many rules have no counters so we need to supply values
                #       for the stats collection here too.
                PPS = BPS = 0
                PPSText = BPSText = HumanPacketsText = HumanBytesText = HumanPPSText = HumanBPSText  = ''

            else:
                LogWrite.error('Unexpected error occurred')

            # Write out a list of dicts for the current stats:
            NftStats.LastSplitNftOutput.append({
                'Handle': HandleResult,                                         # int
                'HandleText': HandleTextResult,                                 # string

                'Packets': PacketsResult,                                       # int
                'PacketsText': PacketsTextResult,                               # string

                'HumanPacketsText': HumanPacketsText,                           # string

                'PPS' : PPS,                                                    # int
                'PPSText': PPSText,                                             # string

                'HumanPPSText': HumanPPSText,                                   # string

                'Bytes': BytesResult,                                           # int
                'BytesText': BytesTextResult,                                   # string

                'HumanBytesText': HumanBytesText,                               # string

                'BPS' : BPS,                                                    # int
                'BPSText': BPSText,                                             # string

                'HumanBPSText': HumanBPSText,                                   # string

                'CommentText': CommentResult,                                   # string

                'LeadingWhitespace': LeadingWhitespaceResult,                   # string

                'DetailsText': DetailsResult,                                   # string
                })

        # Collect the max item lengths:
        NftStats.LastMaxLengths.update({
            'MaxHandleTextLength': MaxHandleTextLength,                     # int
            'MaxPacketsTextLength': MaxPacketsTextLength,                   # int
            'MaxHumanPacketsTextLength': MaxHumanPacketsTextLength,         # int
            'MaxPPSTextLength': MaxPPSTextLength,                           # int
            'MaxHumanPPSTextLength': MaxHumanPPSTextLength,                 # int
            'MaxBytesTextLength': MaxBytesTextLength,                       # int
            'MaxHumanBytesTextLength': MaxHumanBytesTextLength,             # int
            'MaxBPSTextLength': MaxBPSTextLength,                           # int
            'MaxHumanBPSTextLength': MaxHumanBPSTextLength,                 # int
            'MaxCommentTextLength': MaxCommentTextLength,                   # int
            'MaxDetailsTextLength': MaxDetailsTextLength                    # int
            })
        #LogWrite.debug('NftStats.LastMaxLengths == {}'.format(NftStats.LastMaxLengths))

        #LogLastSplitNftOutput()
            # ^ Too much logging
        NftStats.NftReadCycle += 1
        NftStats.LenLastRead = len(NftStats.LastSplitNftOutput)
        NftStats.PreviousSplitNftOutput = NftStats.LastSplitNftOutput
        NftStats.LenPrevRead = len(NftStats.PreviousSplitNftOutput)
        NftStats.PreviousMaxLengths = NftStats.LastMaxLengths

        if GlobalConfig.RefreshScreen:
            # ^ Did the user request a pause display?
            NftStats.FreezeSplitNftOutput = NftStats.LastSplitNftOutput
            NftStats.FreezeMaxLengths = NftStats.LastMaxLengths
            NftStats.LenFreezeRead = len(NftStats.FreezeSplitNftOutput)
            #LogWrite.debug('NftStats.LenFreezeRead == {}'.format(NftStats.LenFreezeRead))

                # ^ Use this for display, allowing pause mode scroll while still updating the stats in the background.
                #   If output paused - the frozen status (NftStats.FreezeSplitNftOutput) doesn't update - allowing
                #       the user to scroll the display without updates.

        PopulateWindows()
        DisplayWindows()

        #if GlobalConfig.RefreshScreen:
        # ^ I dont believe this check is required
        SmartSleep()

        if GlobalConfig.ExitProgram:
            break


def SmartSleep():
    '''  Sleep the defined time but periodically check if need to exit '''

    Counter = 0

    if GlobalConfig.SkipSleep:
        pass
        # ^ Only sleep in refresh mode (not paused) - this will allow the user to scroll the display
        #       without delays.

    else:
        if GlobalConfig.RefreshPeriod <= GlobalConfig.MiniSleep:
            time.sleep(GlobalConfig.RefreshPeriod)
        else:
            while True:
                if GlobalConfig.ForceScreenRedraw:
                    PopulateWindows()
                    DisplayWindows()
                    # ^ Note - redrawing windows can only happen from within function:  ReadNftOutput
                    #       or functions called from within it - this is to avoid doing a redraw while
                    #       stats are still being written (multi threading issue).
                    GlobalConfig.ForceScreenRedraw = False

                if GlobalConfig.SkipSleep:
                    break
                time.sleep(GlobalConfig.MiniSleep)
                Counter += GlobalConfig.MiniSleep
                if Counter >= GlobalConfig.RefreshPeriod:
                    break

    GlobalConfig.SkipSleep = False


def LogLastSplitNftOutput():
    for Looper in NftStats.LastSplitNftOutput:
        LogWrite.debug('Looper == {}'.format(Looper))


def LoadConfigFile():
    ''' Loads the nftwatch.yml config file from the first path found '''

    for FileLooper in GlobalConfig.ConfigFilePath:
        if pathlib.Path(FileLooper).exists():
            break

    # This block addresses issue #2 :
    if pathlib.Path(FileLooper).exists():
        LogWrite.debug('Found config file: FileLooper == {}'.format(FileLooper))
    else:
        LogWrite.info('nftwatch.yml config file not found in any of the paths - using builtin defaults')
        return

    with open (FileLooper, 'r') as ConfigFileToRead:
        LoadedConfigDict = yaml.safe_load(ConfigFileToRead)
            # ^ yaml.load is not safe
        # ^ Now we have the nftwatch.yml file loaded into LoadedConfigDict.
        #   This is both the ssh connections details as well as the
        #   nccm_config_* items - all in the same dict.

    LogWrite.debug('LoadedConfigDict (contains prog settings + conn details) == {}'
            .format(LoadedConfigDict))
        # ^ This dump will have program config + connection config details.
        #   Soon we will pop out the program config items.

    LogWrite.debug('Extracting program configs from LoadedConfigDict ...')

    # Handle loading of the NftCommandLine setting:
    GlobalConfig.NftCommandLine = LoadedConfigDict.pop(
        'nftwatch_config_NftCommandLine', 'none').lower()
    LogWrite.debug('Loaded {} config item:  NftCommandLine == {}'
        .format(GlobalConfig.ConfigFile, GlobalConfig.NftCommandLine))

    # Handle loading of the RefreshPeriod setting:
    GlobalConfig.RefreshPeriod = float(LoadedConfigDict.pop(
        'nftwatch_config_RefreshPeriod', '2'))
    LogWrite.debug('Loaded {} config item:  RefreshPeriod == {}'
        .format(GlobalConfig.ConfigFile, GlobalConfig.RefreshPeriod))

    # Handle loading of the DisplayHandle setting:
    GlobalConfig.DisplayHandle = LoadedConfigDict.pop(
        'nftwatch_config_DisplayHandle:', True)
    LogWrite.debug('Loaded {} config item:  DisplayHandle == {}'
        .format(GlobalConfig.ConfigFile, GlobalConfig.DisplayHandle))

    # Handle loading of the TruncateComment setting:
    GlobalConfig.TruncateComment = int(LoadedConfigDict.pop(
        'nftwatch_config_TruncateComment', '0'))
    LogWrite.debug('Loaded {} config item:  TruncateComment == {}'
        .format(GlobalConfig.ConfigFile, GlobalConfig.TruncateComment))

    # Handle loading of the TruncateDetails setting:
    GlobalConfig.TruncateDetails = int(LoadedConfigDict.pop(
        'nftwatch_config_TruncateDetails', '0'))
    LogWrite.debug('Loaded {} config item:  TruncateDetails == {}'
        .format(GlobalConfig.ConfigFile, GlobalConfig.TruncateDetails))

    # Handle loading of the DisplayMode setting:
    GlobalConfig.DisplayMode = LoadedConfigDict.pop(
        'nftwatch_config_DisplayMode', 'human').lower()
    LogWrite.debug('Loaded {} config item:  DisplayMode == {}'
        .format(GlobalConfig.ConfigFile, GlobalConfig.DisplayMode))


def RestoreTerminal(stdscr):
    ''' Restore the terminal to a sane status '''

    curses.curs_set(1)          # Restore blinking cursor
    curses.echo()               # Restore terminal echo
    stdscr.keypad(False)        # Return special keys to normal
    curses.noraw()              # Return raw mode to normal
    curses.endwin()             # End curses session


def SetupCurses(stdscr):
    ''' Put all pre-run tests here. Any failure will exit the program. '''

    LogWrite.debug('Function SetupCurses started')
    curses.curs_set(0)          # Completely hide the cursor
    curses.noecho()             # Disable echo to the terminal
    stdscr.keypad(True)
        # ^ Get special keys support in stdscr. Per window setting also required
    curses.raw()                # Disable control codes

    # Set up the vars for use later by:  curses.color_pair :
    curses.init_pair(1, curses.COLOR_YELLOW, curses.COLOR_BLACK)
        # ^ Used by the help menu shortcut key display
    curses.init_pair(2, curses.COLOR_CYAN, curses.COLOR_BLACK)
        # ^ Used by the help menu shortcut key help test
    curses.init_pair(3, curses.COLOR_YELLOW, curses.COLOR_BLUE)
        # Used by the text box as supplied to:  class TextBox
    curses.init_pair(4, curses.COLOR_WHITE, curses.COLOR_RED)
        # ^ Used by the marker line controlled by the arrows
    curses.init_pair(5, curses.COLOR_WHITE, curses.COLOR_RED)
        # ^ Used for setting alerts such as 'LogPrv'
    curses.init_pair(6, curses.COLOR_MAGENTA, curses.COLOR_BLACK)
        # ^ Used for setting alerts such as 'LogTee'
    curses.init_pair(7, curses.COLOR_WHITE, curses.COLOR_BLACK)
        # ^ Used for setting alerts such as 'LogTee'
    curses.init_pair(8, curses.COLOR_RED, curses.COLOR_BLACK)
        # ^ Used for setting alerts such as 'LogTee'
    curses.init_pair(9, curses.COLOR_GREEN, curses.COLOR_BLACK)
        # ^ Used for setting alerts such as 'LogTee'

    if not curses.has_colors(): # Color not supported
        RestoreTerminal(stdscr)
        LogWrite.warning( { 'tee': '\nnftwatch requires color support\n' } )
        return False

    GlobalConfig.ScreenHeight, GlobalConfig.ScreenWidth = stdscr.getmaxyx()
    LogWrite.debug('GlobalConfig.ScreenHeight == {} , GlobalConfig.ScreenWidth == {}'
        .format(GlobalConfig.ScreenHeight, GlobalConfig.ScreenWidth))

    GlobalConfig.MaxScreenLines = ( GlobalConfig.ScreenHeight - 2 )
    GlobalConfig.DetailsWidth = ( GlobalConfig.ScreenWidth - GlobalConfig.CountersWidth - 1 )
    LogWrite.debug('GlobalConfig.MaxScreenLines == {} , GlobalConfig.DetailsWidth == {}'
        .format(GlobalConfig.MaxScreenLines, GlobalConfig.DetailsWidth))

    if GlobalConfig.ScreenWidth < 60 or GlobalConfig.ScreenHeight < 15:
        RestoreTerminal(stdscr)
        LogWrite.warning( { 'tee': '\nnftwatch window must be at least 60x15. GlobalConfig.ScreenHeight == {} , GlobalConfig.ScreenWidth == {}\n'
                .format(GlobalConfig.ScreenHeight, GlobalConfig.ScreenWidth) } )
        return False

    LogWrite.debug('Function SetupCurses should have completed successfully')


def SetupWindows(stdscr):
    ''' Create the various windows '''

    LogWrite.debug('Function SetupWindows started - create the various windows')

    # Build the various windows:

    # Build the help box:
    Windows.HelpBox = curses.newwin(1, 10, GlobalConfig.ScreenHeight-1, 0)
        # ^ curses.newwin(nlines, ncols, begin_y, begin_x)

    for Looper in GlobalConfig.HelpMenuItems:
        Windows.HelpBox.addstr('  '+Looper, curses.color_pair(1))
        Windows.HelpBox.addstr('-'+GlobalConfig.HelpMenuItems[Looper], curses.color_pair(2))

    # Build the status box:
    Windows.StatusBox = curses.newwin(1, 45, GlobalConfig.ScreenHeight-1, 12)
        # ^ curses.newwin(nlines, ncols, begin_y, begin_x)
        #   If you overrun this window you get this error:
        #       _curses.error: addwstr() returned ERR
    Windows.StatusBox.addstr('Update='+str(GlobalConfig.RefreshScreen), curses.color_pair(9))
        # ^ This is the refresh (pause in reverse) status
    Windows.StatusBox.addstr('  Sleep='+str(GlobalConfig.RefreshPeriod), curses.color_pair(9))
        # ^ This is the sleep time between refreshes

    Windows.HelpBox.keypad(True)
        # ^ Get special keys support for this window.
        #   Calling 'stdscr.keypad(True)' is different and doesn't reflect
        #   in windows - it must be called separately.
        #   Very important - otherwise stuff like getch return stuff like arrow keys
        #   in multiple bytes (one per call) and it's screwed up.

    LogWrite.debug('Help box built')

    # Build the counters title box:
    #   Example of title max char length as follows:
    #   1234  123 K  456 M  123 K  456 M
    #       This equates to 32 chars which I fixed into:  GlobalConfig.CountersWidth
    Windows.CountersTitleBox = curses.newwin(1, GlobalConfig.CountersWidth, 0, 0)
    Windows.CountersTitleBox.addstr('LINE  HNDL  PKTS   BYTES  PPS    BPS', curses.color_pair(3))
    LogWrite.debug('Counters title box built')

    # Build the counters output box:
    Windows.CountersOutputBox = curses.newwin(GlobalConfig.MaxScreenLines, GlobalConfig.CountersWidth, 1, 0)
    LogWrite.debug('Counters output box built')

    # Build the details title box:
    Windows.DetailsTitleBox = curses.newwin(1, GlobalConfig.DetailsWidth, 0, GlobalConfig.CountersWidth)
    #Windows.DetailsTitleBox.addstr('COMMENTS & DETAILS', curses.color_pair(3))

    # Setup a string with the title of the:  comments & details  window:
    DetailsStr = ('{:<{ColWidth}}'
        .format(
            'COMMENTS & DETAILS',
            ColWidth = ( GlobalConfig.DetailsWidth - 1 ) ))
    #LogWrite.debug('DetailsStr == "{}"'.format(DetailsStr))

    # Now use the string we created above to create the title box:
    Windows.DetailsTitleBox.addstr(DetailsStr, curses.color_pair(3))
        # ^ todo - this needs to respect the max column width
    LogWrite.debug('Details title box built')

    # Build the details output box:
    Windows.DetailsOutputBox = curses.newwin(GlobalConfig.MaxScreenLines, GlobalConfig.DetailsWidth, 1, GlobalConfig.CountersWidth)
    LogWrite.debug('Details output box built')

    DisplayWindows()
    LogWrite.debug('Function SetupWindows ended')


def PopulateWindows():

    Windows.CountersOutputBox.erase()
    Windows.DetailsOutputBox.erase()
    Windows.StatusBox.erase()
    CounterString = ''

    LinesToDisplay = min( ( GlobalConfig.VerticalOffset + GlobalConfig.ScreenHeight - 3 ), NftStats.LenFreezeRead )
        # ^ Issue #3 - nftwatch crashes if table shorter than page height

    #LogWrite.debug('GlobalConfig.VerticalOffset == {} , '
    #    'GlobalConfig.VerticalOffset + GlobalConfig.ScreenHeight - 3 == {} , '
    #    'NftStats.LenFreezeRead == {} , LinesToDisplay == {}'
    #        .format(GlobalConfig.VerticalOffset,
    #            ( GlobalConfig.VerticalOffset + GlobalConfig.ScreenHeight - 3 ),
    #            NftStats.LenFreezeRead, LinesToDisplay ))

    for Looper in range(GlobalConfig.VerticalOffset, LinesToDisplay):

        if GlobalConfig.DisplayMode == 'human':

            CounterString = ( '{:<6}{:<6}{:<7}{:<7}{:<7}{:<7}\n'
                .format(
                    str(Looper+1),
                    NftStats.FreezeSplitNftOutput[Looper]['HandleText'],
                    NftStats.FreezeSplitNftOutput[Looper]['HumanPacketsText'],
                    NftStats.FreezeSplitNftOutput[Looper]['HumanBytesText'],
                    NftStats.FreezeSplitNftOutput[Looper]['HumanPPSText'],
                    NftStats.FreezeSplitNftOutput[Looper]['HumanBPSText']) )

            Windows.CountersOutputBox.addstr(str(CounterString), curses.color_pair(7))
                # ^ The counters have a fixed width and do not scroll. Therefore we can
                #       immediately add it to the curses window.

            if GlobalConfig.TruncateComment < 1000:
                MaxCommentLen = GlobalConfig.TruncateComment
            else:
                MaxCommentLen = NftStats.FreezeMaxLengths['MaxCommentTextLength']
            #LogWrite.debug('MaxCommentLen == {}'.format(MaxCommentLen))

            if GlobalConfig.MoreDotPadding:
                FullCommentText = NftStats.FreezeSplitNftOutput[Looper]['CommentText'][0:MaxCommentLen].ljust((MaxCommentLen), '.')
            elif ( GlobalConfig.DotPadding ) and ( len(NftStats.FreezeSplitNftOutput[Looper]['CommentText']) > 0 ):
                FullCommentText = NftStats.FreezeSplitNftOutput[Looper]['CommentText'][0:MaxCommentLen].ljust((MaxCommentLen), '.')
                # ^ Here we collect the first n chars of the comment in case the config file
                #       said to truncate it.
            else:
                FullCommentText = NftStats.FreezeSplitNftOutput[Looper]['CommentText'][0:MaxCommentLen].ljust((MaxCommentLen), ' ')

            if GlobalConfig.MoreDotPadding:
                DetailsString = FullCommentText + NftStats.FreezeSplitNftOutput[Looper]['LeadingWhitespace'].replace(' ', '.') + '  ' + NftStats.FreezeSplitNftOutput[Looper]['DetailsText']
                    # ^ This generates the entire length of the comment+details string
            else:
                DetailsString = FullCommentText + NftStats.FreezeSplitNftOutput[Looper]['LeadingWhitespace'] + '  ' + NftStats.FreezeSplitNftOutput[Looper]['DetailsText']

            DetailsString = DetailsString[0:GlobalConfig.DetailsWidth - 1] + '\n'
                # ^ Now truncate it to the width of the details window

            Windows.DetailsOutputBox.addstr(str(DetailsString), curses.color_pair(7))

    Windows.StatusBox.addstr('Update='+str(GlobalConfig.RefreshScreen), curses.color_pair(9))
    Windows.StatusBox.addstr('  Sleep='+str(GlobalConfig.RefreshPeriod), curses.color_pair(9))


def DisplayWindows():
    # Prepare the various windows for display:
    Windows.HelpBox.noutrefresh()
    Windows.StatusBox.noutrefresh()
    Windows.CountersTitleBox.noutrefresh()
    Windows.CountersOutputBox.noutrefresh()
    Windows.DetailsTitleBox.noutrefresh()
    Windows.DetailsOutputBox.noutrefresh()

    curses.doupdate()
        # ^ Speed up display and avoid flickering by using 'window.noutrefresh'
        #   This command actually displays the windows we prepared earlier.

    #LogWrite.debug('Menus should be displayed at this stage')
        # ^ Too much logging


def MainCursesFunction(stdscr):

    LogWrite.debug('Function MainCursesFunction started. stdscr == {}'.format(stdscr))

    if SetupCurses(stdscr) == False:
        # ^ Something failed in setup or tests
        LogWrite.error('SetupCurses(stdscr) failed')
        return

    SetupWindows(stdscr)

    while True:

        UserKey = Windows.HelpBox.getch()
        #UserKey = stdscr.getch()
            # ^ Do not use getch on stdscr - this causes display to disappear.
            #   It must be run on one of the windows that has:  xxx.keypad(True)  configured.
            #   I set it here:   Windows.HelpBox.keypad(True)  so use HelpBox for the reader.
            #   Per the docs here:  https://docs.python.org/3/howto/curses.html  - getch
            #       refreshes the screen and then waits for input. But we have windows, not only
            #       the main stdscr screen, so refreshing stdscr will make the display disappear.
        LogWrite.debug('UserKey == {}'.format(UserKey))

        if UserKey in [17, 113]:
            # ^ ctrl-q or q key to Quit
            GlobalConfig.ExitProgram = True
            GlobalConfig.SkipSleep = True
            LogWrite.info('User requested quit program. Cleaning up and exiting ...')
            break

        elif UserKey == 112:
            # ^ p key to Pause output
            GlobalConfig.RefreshScreen = not GlobalConfig.RefreshScreen
                # ^ Flip the setting

        elif UserKey == 46:
            # ^ . key to use dot padding
            GlobalConfig.DotPadding = not GlobalConfig.DotPadding
            if GlobalConfig.DotPadding:
                GlobalConfig.MoreDotPadding = False

        elif UserKey == 44:
            # ^ , key to use more dot padding
            GlobalConfig.MoreDotPadding = not GlobalConfig.MoreDotPadding
            if GlobalConfig.MoreDotPadding:
                GlobalConfig.DotPadding = False

        elif UserKey == 102:
            # ^ f key to make display update Faster (halve:  GlobalConfig.RefreshPeriod)
            if ( GlobalConfig.RefreshPeriod / 2 ) >= 0.1:
                GlobalConfig.RefreshPeriod = ( GlobalConfig.RefreshPeriod / 2 )
                #LogWrite.debug('GlobalConfig.RefreshPeriod == {}'.format(GlobalConfig.RefreshPeriod) )
            GlobalConfig.ForceScreenRedraw = True

        elif UserKey == 115:
            # ^ s key to make display update Slower (double:  GlobalConfig.RefreshPeriod)
            GlobalConfig.RefreshPeriod = ( GlobalConfig.RefreshPeriod * 2 )
            #LogWrite.debug('GlobalConfig.RefreshPeriod == {}'.format(GlobalConfig.RefreshPeriod) )
            GlobalConfig.ForceScreenRedraw = True

        elif UserKey in [110, 258]:
            # ^ arrow down key or n
            if NftStats.LenLastRead >= ( GlobalConfig.VerticalOffset + GlobalConfig.MaxScreenLines ):
                # ^ Are there enough lines below to allow scroll down by one line?
                GlobalConfig.VerticalOffset += 1
                #LogWrite.debug('GlobalConfig.VerticalOffset == {}'.format(GlobalConfig.VerticalOffset))
            GlobalConfig.ForceScreenRedraw = True

        elif UserKey in [78, 259]:
            # ^ arrow up key or N
            if GlobalConfig.VerticalOffset > 0:
                # ^ Are there enough lines below to allow scroll up by one line?
                GlobalConfig.VerticalOffset -= 1
                #LogWrite.debug('GlobalConfig.VerticalOffset == {}'.format(GlobalConfig.VerticalOffset))
            GlobalConfig.ForceScreenRedraw = True

        elif UserKey in [103, 262]:
            # ^ home key or g key
            GlobalConfig.VerticalOffset = 0
            #LogWrite.debug('GlobalConfig.VerticalOffset == {}'.format(GlobalConfig.VerticalOffset))
            GlobalConfig.ForceScreenRedraw = True

        elif UserKey in [71, 360]:
            # ^ end key or G key
            if ( NftStats.LenFreezeRead > ( GlobalConfig.ScreenHeight - 3 ) ):
                GlobalConfig.VerticalOffset = ( NftStats.LenLastRead - GlobalConfig.MaxScreenLines + 1 )
                #LogWrite.debug('GlobalConfig.VerticalOffset == {}'.format(GlobalConfig.VerticalOffset))
                GlobalConfig.ForceScreenRedraw = True

        elif UserKey in [32, 338]:
            # ^ page down key or space bar
            if NftStats.LenLastRead >= ( GlobalConfig.VerticalOffset + GlobalConfig.MaxScreenLines ):
                # ^ Are there enough lines below to allow page down?
                if NftStats.LenLastRead >= ( GlobalConfig.VerticalOffset + ( GlobalConfig.MaxScreenLines * 2 ) ):
                    GlobalConfig.VerticalOffset += ( GlobalConfig.MaxScreenLines - 1 )
                else:
                    GlobalConfig.VerticalOffset = ( NftStats.LenLastRead - GlobalConfig.MaxScreenLines + 1 )
                #LogWrite.debug('GlobalConfig.VerticalOffset == {}'.format(GlobalConfig.VerticalOffset))
            GlobalConfig.ForceScreenRedraw = True

        elif UserKey in [98, 339]:
            # ^ page up key or b key
            if GlobalConfig.VerticalOffset > 0:
                # ^ Are there enough lines above to allow page up?
                if GlobalConfig.VerticalOffset >= ( GlobalConfig.MaxScreenLines ):
                #if NftStats.LenLastRead >= ( GlobalConfig.VerticalOffset - GlobalConfig.MaxScreenLines ):
                    GlobalConfig.VerticalOffset -= ( GlobalConfig.MaxScreenLines - 1 )
                else:
                    GlobalConfig.VerticalOffset = 0
                #LogWrite.debug('GlobalConfig.VerticalOffset == {}'.format(GlobalConfig.VerticalOffset))
            GlobalConfig.ForceScreenRedraw = True

        # Check if the window was resized since it was started:
        NewScreenHeight, NewScreenWidth = stdscr.getmaxyx()
            # ^ Reading getmaxyx is done on the object:  stdscr  which is generated
            #       by:  curses.wrapper  .
        LogWrite.debug('class Connections, method: Display: '
            'NewScreenHeight == {} , NewScreenWidth == {} '
                .format(NewScreenHeight, NewScreenWidth))

        if NewScreenHeight != GlobalConfig.ScreenHeight or NewScreenWidth != GlobalConfig.ScreenWidth:
            RestoreTerminal(stdscr)
            LogWrite.warning( { 'tee': '\nResizing the window when nftwatch is active is not supported\n\n' } )
            GlobalConfig.ExitProgram = True
            GlobalConfig.SkipSleep = True
            break


def InitialLogging():
    ''' Put any useful logging here - such as startup env details.
        This will require DEBUG level logging, so start nftwatch
        in debug mode with the -d command line arg.

        Or set the line as follows:
            LogLevel = logging.DEBUG
    '''

    IntroLine = ('{} v{} , {} , by: {} ( {} )'
        .format(ProgramName, __version__, VersionDate, AuthorName, AuthorEmail))

    LogWrite.info(IntroLine)
    LogWrite.info( {
        'unsafe': 'Invoked commandline: {CmdLine} , from directory: {Dir} , '
            'by user: {User} , UID: {UID} , PPID: {PPID} , log level: {LogLevel}'
                .format(
                    CmdLine = sys.argv,
                    Dir = os.getcwd(),
                    User = getpass.getuser(),
                    UID = os.getuid(),
                    PPID = os.getppid(),
                    LogLevel = LogLevel ),
        'safe':   'Invoked commandline: CENSORED , from directory: CENSORED , '
        'by user: CENSORED , UID: CENSORED , PPID: CENSORED , log level: {LogLevel}'
            .format(LogLevel = LogLevel) } )


    LogWrite.info('Fields explained: PN: Process Name , MN: Module Name , '
        'FN: Function Name , LI: LIne number , '
        'TN: Thread Name')

    if not SecureLogging:
        LogWrite.warning('Attention:  SecureLogging == False  -->  '
            'sensitive information will be logged to syslog/journal !')


def DisplayHelp():
    ''' Display the help text '''

    LogWrite.debug('Displaying help...')
    pydoc.pipepager(__doc__, cmd='less -i --dumb --no-init')
        # ^ Print the text in through the less pager
        #   so we can get paging, search, etc


def ParseArgs():
    ''' Handle any command line arguments supplied '''

    global SecureLogging

    parser = argparse.ArgumentParser(
        description = 'nftables counters watcher by Kenneth Aaron',
        epilog = 'Thank you for using nftwatch',
        #add_help = False )
            # ^ Bypass the built in argparse help generator and release
            #   the -h and --help args for our own use.
        )

    parser.add_argument('-d', '--debug',
        help='force debug verbosity logging, ignore other logging settings',
        action='store_true' )

    parser.add_argument('-m', '--man',
        help='display nftwatch man page and exit',
        action='store_true' )

    parser.add_argument('-v', '--version',
        help='show version and exit',
        action='store_true' )

    parser.add_argument('--logprivateinfo',
        help='log uncensored usernames, hostnames, etc',
        action='store_true' )

    args = parser.parse_args()
    #LogWrite.debug('args object = {}'.format(args))
        # ^ Exposes private info before we get a chance to check the command
        #       line args whether the user allows private info logging.

    if args.logprivateinfo:
        SecureLogging = False
        LogWrite.warning('--logprivateinfo command line argument supplied - '
            'stuff like usernames and hostnames will be logged to syslog/journal !')

    if args.debug:
        LogWrite.setLevel(logging.DEBUG)
        GlobalConfig.ForceDebugLogging = True
        LogWrite.debug('Received command line arg --debug forcing nftwatch '
            'to run in debug mode')

    LogWrite.debug('parser object = {}'.format(parser))
    LogWrite.debug( {
        'unsafe':   'args object == {}'.format(args),
        'safe':     'args object == CENSORED' } )
        # ^ Huh? I set:  nccm_config_logprivateinfo: true  in nftwatch.yml but I am still
        #       seeing CENSORED in the logs! That's because this setting hasn't loaded yet.
        #   Force it with command line arg:  --logprivateinfo

    if args.man:
        DisplayHelp()
        GlobalConfig.ExitProgram = True

    if args.version:
        print(__version__)
        GlobalConfig.ExitProgram = True


def main(*args):

    ParseArgs()     # Command line args processing happens here

    if GlobalConfig.ExitProgram:
        return

    InitialLogging()
        # ^ Moved it after ParseArgs so that we have debugging info logged if
        #   started using 'nftwatch -d' .

    #if not getpass.getuser() == 'root':
    if not os.geteuid() == 0:
        # ^ Addressing issue #1
        LogWrite.warning( { 'tee': 'nftwatch must be run as root (or sudo) because nft requires root to read stats' } )
        return

    LogWrite.debug('Python version == {}'.format(sys.version_info))

    if ( ( sys.version_info[0] < 3 ) and ( sys.version_info[1] < 6 ) ):
        LogWrite.warning( { 'tee': 'Requires python 3.6+' } )
        return

    LoadConfigFile()

    # Start nft reading thread now:
    NftReadThread = threading.Thread(target = ReadNftOutput)
    LogWrite.debug('About to start NftReadThread == {}'.format(NftReadThread))
    NftReadThread.start()

    curses.wrapper(MainCursesFunction)
        # ^ This wrapper creates:  stdscr  that is passed to the function:  MainCursesFunction .
        #   Documented here:  https://docs.python.org/3/library/curses.html  under:  curses.wrapper

    # Wait for:  NftReadThread  thread to exit (because it does screen draws).
    #   curses.wrapper(...)  will cleanup the window and restore the terminal to sane conditions
    #   but this can happen only after no more screen draws occur :

    LogWrite.debug('NftReadThread alive status == {}'.format(NftReadThread.is_alive()))

    for Looper in range (50):
        if not NftReadThread.is_alive():
            break
        time.sleep (GlobalConfig.MiniSleep)

    LogWrite.debug('NftReadThread alive status == {}'.format(NftReadThread.is_alive()))

    # ^ Note - the block above is supposed to let curses restore the terminal to a sane
    #       condition but it doesn't always happen. Need to figure out why.


if __name__ == '__main__':
    ScriptStartTime = time.time()
    main()

    LogWrite.info('{} exiting. Program run time: {:.3f} seconds'
        .format(ProgramName, time.time() - ScriptStartTime))


